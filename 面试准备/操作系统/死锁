死锁的原因和必要条件
什么是死锁
所谓死锁：是指多个进程在运行过程中因争夺资源而造成的一种僵局。

产生死锁的原因
竞争资源：当系统中多个进程使用共享资源，并且资源不足以满足需要，会引起进程对资源的竞争而产生死锁。
进程间推进的顺序非法：请求和释放资源的顺序不当，也同样会导致产生进程死锁

 

产生死锁的必要条件
互斥条件：进程对所分配到的资源进行排它性使用，在一段时间内某资源只由一个进程占用。
请求和保持条件：指一个进程已经保持了至少一个资源，但又提出新的资源请求，而此资源被其他占用，此时请求进程阻塞，但又对自己已经占用的资源保持不放。
不剥夺条件：进程已经获得资源，在未使用完之前，不能被剥夺，只能在使用完时，由进程自己释放。
环路等待条件：发生死锁时，必然存在一个进程-资源的环形链。
 

处理死锁的方法

预防死锁
事先预防，破坏产生死锁的四个必要条件之一。
摒弃“请求和保持”条件：
进程在申请资源时，是一次性的。
如何摒弃“请求“：当进程来时，一次性分配所有的资源（如果系统满足），这样就不会再有”请求“了。
如何摒弃“保持“：只要有一个资源得不到分配，也不给这个进程分配其他的资源。
摒弃“不剥夺”条件:在这种方法中，进程是逐个提出对资源的要求的。如果一个进程，获得了部分资源，但得不到其它资源，这时，它释放自己所占用的资源。
摒弃“环路等待”条件：把资源排序，当进程申请资源时，按序申请。

避免死锁
事先预防，并不是破坏产生死锁的四个必要条件，而是用某种方法去防止系统进入不安全状态，目前在较完善的系统中，常用此方法。银行家算法
安全状态：是指系统能按照某种进程顺序（P1,P2,…Pn），来为每一个进程Pi分配其所需要的资源，直到满足每个进程对资源的最大需求，使每个进程都可顺利地完成。如果系统无法找到这样一个安全序列，则称系统处于不安全状态。

检测死锁
并不事先采取任何限制性的措施，也不必检查系统是否已经进入不安全区，此方法允许发生死锁，关键是，发生死锁了，系统可以通过检测机构发现死锁，并精确确定与死锁有关的进程和资源，然后，采取适当措施，从系统中将已经发生的死锁清除

解除死锁
这是与检测死锁配套使用。当检测到系统已经发生了死锁，要将进程从死锁状态中解脱出来。常用的方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已经处于阻塞状态的进程，使之转为就绪状态，以继续运行。